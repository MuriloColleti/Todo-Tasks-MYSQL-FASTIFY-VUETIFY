// src/index.ts
import { dirname as dirname3, join as join4, resolve as resolve6 } from "node:path";
import { fileURLToPath } from "node:url";
import { mkdirSync as mkdirSync2, rmSync, writeFileSync as writeFileSync2, existsSync as existsSync5 } from "node:fs";

// src/utils/prompts.ts
import { join as join2, resolve as resolve3 } from "node:path";
import { existsSync as existsSync2, readdirSync } from "node:fs";

// src/utils/presets.ts
var defaultContext = {};
var baseContext = {
  ...defaultContext
};
var essentialsContext = {
  ...baseContext
};
var presets = {
  "base": baseContext,
  "default": defaultContext,
  "essentials": essentialsContext,
  "nuxt-base": baseContext,
  "nuxt-default": defaultContext,
  "nuxt-essentials": essentialsContext
};

// src/utils/prompts.ts
import { red } from "kolorist";
import prompts from "prompts";

// node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/shared/pathe.M-eThtNZ.mjs
var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
var _UNC_REGEX = /^[/\\]{2}/;
var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
var _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
var normalize = function(path4) {
  if (path4.length === 0) {
    return ".";
  }
  path4 = normalizeWindowsPath(path4);
  const isUNCPath = path4.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute(path4);
  const trailingSeparator = path4[path4.length - 1] === "/";
  path4 = normalizeString(path4, !isPathAbsolute);
  if (path4.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path4 += "/";
  }
  if (_DRIVE_LETTER_RE.test(path4)) {
    path4 += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path4}`;
    }
    return `//${path4}`;
  }
  return isPathAbsolute && !isAbsolute(path4) ? `/${path4}` : path4;
};
var join = function(...segments) {
  let path4 = "";
  for (const seg of segments) {
    if (!seg) {
      continue;
    }
    if (path4.length > 0) {
      const pathTrailing = path4[path4.length - 1] === "/";
      const segLeading = seg[0] === "/";
      const both = pathTrailing && segLeading;
      if (both) {
        path4 += seg.slice(1);
      } else {
        path4 += pathTrailing || segLeading ? seg : `/${seg}`;
      }
    } else {
      path4 += seg;
    }
  }
  return normalize(path4);
};
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
var resolve = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path4 = index >= 0 ? arguments_[index] : cwd();
    if (!path4 || path4.length === 0) {
      continue;
    }
    resolvedPath = `${path4}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute(path4);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path4, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path4.length; ++index) {
    if (index < path4.length) {
      char = path4[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path4.slice(lastSlash + 1, index)}`;
        } else {
          res = path4.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var isAbsolute = function(p) {
  return _IS_ABSOLUTE_RE.test(p);
};

// node_modules/.pnpm/tinyexec@1.0.1/node_modules/tinyexec/dist/main.js
import { createRequire as __tinyexec_cr } from "node:module";
import { spawn as de } from "child_process";
import { normalize as fe } from "path";
import { cwd as he } from "process";
import {
  delimiter as N,
  resolve as qt,
  dirname as It
} from "path";
import { PassThrough as zt } from "stream";
import me from "readline";
var require2 = __tinyexec_cr(import.meta.url);
var St = Object.create;
var $ = Object.defineProperty;
var kt = Object.getOwnPropertyDescriptor;
var Tt = Object.getOwnPropertyNames;
var At = Object.getPrototypeOf;
var Rt = Object.prototype.hasOwnProperty;
var h = /* @__PURE__ */ ((t) => typeof require2 < "u" ? require2 : typeof Proxy < "u" ? new Proxy(t, {
  get: (e, n) => (typeof require2 < "u" ? require2 : e)[n]
}) : t)(function(t) {
  if (typeof require2 < "u") return require2.apply(this, arguments);
  throw Error('Dynamic require of "' + t + '" is not supported');
});
var l = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var $t = (t, e, n, r) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let s of Tt(e))
      !Rt.call(t, s) && s !== n && $(t, s, { get: () => e[s], enumerable: !(r = kt(e, s)) || r.enumerable });
  return t;
};
var Nt = (t, e, n) => (n = t != null ? St(At(t)) : {}, $t(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e || !t || !t.__esModule ? $(n, "default", { value: t, enumerable: true }) : n,
  t
));
var W = l((Se, H) => {
  "use strict";
  H.exports = z;
  z.sync = Wt;
  var j = h("fs");
  function Ht(t, e) {
    var n = e.pathExt !== void 0 ? e.pathExt : process.env.PATHEXT;
    if (!n || (n = n.split(";"), n.indexOf("") !== -1))
      return true;
    for (var r = 0; r < n.length; r++) {
      var s = n[r].toLowerCase();
      if (s && t.substr(-s.length).toLowerCase() === s)
        return true;
    }
    return false;
  }
  function F(t, e, n) {
    return !t.isSymbolicLink() && !t.isFile() ? false : Ht(e, n);
  }
  function z(t, e, n) {
    j.stat(t, function(r, s) {
      n(r, r ? false : F(s, t, e));
    });
  }
  function Wt(t, e) {
    return F(j.statSync(t), t, e);
  }
});
var X = l((ke, B) => {
  "use strict";
  B.exports = K;
  K.sync = Dt;
  var D = h("fs");
  function K(t, e, n) {
    D.stat(t, function(r, s) {
      n(r, r ? false : M(s, e));
    });
  }
  function Dt(t, e) {
    return M(D.statSync(t), e);
  }
  function M(t, e) {
    return t.isFile() && Kt(t, e);
  }
  function Kt(t, e) {
    var n = t.mode, r = t.uid, s = t.gid, o = e.uid !== void 0 ? e.uid : process.getuid && process.getuid(), i = e.gid !== void 0 ? e.gid : process.getgid && process.getgid(), a = parseInt("100", 8), c = parseInt("010", 8), u = parseInt("001", 8), f = a | c, p = n & u || n & c && s === i || n & a && r === o || n & f && o === 0;
    return p;
  }
});
var U = l((Ae, G) => {
  "use strict";
  var Te = h("fs"), v;
  process.platform === "win32" || global.TESTING_WINDOWS ? v = W() : v = X();
  G.exports = y;
  y.sync = Mt;
  function y(t, e, n) {
    if (typeof e == "function" && (n = e, e = {}), !n) {
      if (typeof Promise != "function")
        throw new TypeError("callback not provided");
      return new Promise(function(r, s) {
        y(t, e || {}, function(o, i) {
          o ? s(o) : r(i);
        });
      });
    }
    v(t, e || {}, function(r, s) {
      r && (r.code === "EACCES" || e && e.ignoreErrors) && (r = null, s = false), n(r, s);
    });
  }
  function Mt(t, e) {
    try {
      return v.sync(t, e || {});
    } catch (n) {
      if (e && e.ignoreErrors || n.code === "EACCES")
        return false;
      throw n;
    }
  }
});
var et = l((Re, tt) => {
  "use strict";
  var g = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", Y = h("path"), Bt = g ? ";" : ":", V = U(), J = (t) => Object.assign(new Error(`not found: ${t}`), { code: "ENOENT" }), Q = (t, e) => {
    let n = e.colon || Bt, r = t.match(/\//) || g && t.match(/\\/) ? [""] : [
      // windows always checks the cwd first
      ...g ? [process.cwd()] : [],
      ...(e.path || process.env.PATH || /* istanbul ignore next: very unusual */
      "").split(n)
    ], s = g ? e.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", o = g ? s.split(n) : [""];
    return g && t.indexOf(".") !== -1 && o[0] !== "" && o.unshift(""), {
      pathEnv: r,
      pathExt: o,
      pathExtExe: s
    };
  }, Z = (t, e, n) => {
    typeof e == "function" && (n = e, e = {}), e || (e = {});
    let { pathEnv: r, pathExt: s, pathExtExe: o } = Q(t, e), i = [], a = (u) => new Promise((f, p) => {
      if (u === r.length)
        return e.all && i.length ? f(i) : p(J(t));
      let d = r[u], w = /^".*"$/.test(d) ? d.slice(1, -1) : d, m = Y.join(w, t), b = !w && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + m : m;
      f(c(b, u, 0));
    }), c = (u, f, p) => new Promise((d, w) => {
      if (p === s.length)
        return d(a(f + 1));
      let m = s[p];
      V(u + m, { pathExt: o }, (b, Ot) => {
        if (!b && Ot)
          if (e.all)
            i.push(u + m);
          else
            return d(u + m);
        return d(c(u, f, p + 1));
      });
    });
    return n ? a(0).then((u) => n(null, u), n) : a(0);
  }, Xt = (t, e) => {
    e = e || {};
    let { pathEnv: n, pathExt: r, pathExtExe: s } = Q(t, e), o = [];
    for (let i = 0; i < n.length; i++) {
      let a = n[i], c = /^".*"$/.test(a) ? a.slice(1, -1) : a, u = Y.join(c, t), f = !c && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + u : u;
      for (let p = 0; p < r.length; p++) {
        let d = f + r[p];
        try {
          if (V.sync(d, { pathExt: s }))
            if (e.all)
              o.push(d);
            else
              return d;
        } catch {
        }
      }
    }
    if (e.all && o.length)
      return o;
    if (e.nothrow)
      return null;
    throw J(t);
  };
  tt.exports = Z;
  Z.sync = Xt;
});
var rt = l(($e, _) => {
  "use strict";
  var nt = (t = {}) => {
    let e = t.env || process.env;
    return (t.platform || process.platform) !== "win32" ? "PATH" : Object.keys(e).reverse().find((r) => r.toUpperCase() === "PATH") || "Path";
  };
  _.exports = nt;
  _.exports.default = nt;
});
var ct = l((Ne, it) => {
  "use strict";
  var st = h("path"), Gt = et(), Ut = rt();
  function ot(t, e) {
    let n = t.options.env || process.env, r = process.cwd(), s = t.options.cwd != null, o = s && process.chdir !== void 0 && !process.chdir.disabled;
    if (o)
      try {
        process.chdir(t.options.cwd);
      } catch {
      }
    let i;
    try {
      i = Gt.sync(t.command, {
        path: n[Ut({ env: n })],
        pathExt: e ? st.delimiter : void 0
      });
    } catch {
    } finally {
      o && process.chdir(r);
    }
    return i && (i = st.resolve(s ? t.options.cwd : "", i)), i;
  }
  function Yt(t) {
    return ot(t) || ot(t, true);
  }
  it.exports = Yt;
});
var ut = l((qe, P) => {
  "use strict";
  var C = /([()\][%!^"`<>&|;, *?])/g;
  function Vt(t) {
    return t = t.replace(C, "^$1"), t;
  }
  function Jt(t, e) {
    return t = `${t}`, t = t.replace(/(\\*)"/g, '$1$1\\"'), t = t.replace(/(\\*)$/, "$1$1"), t = `"${t}"`, t = t.replace(C, "^$1"), e && (t = t.replace(C, "^$1")), t;
  }
  P.exports.command = Vt;
  P.exports.argument = Jt;
});
var lt = l((Ie, at) => {
  "use strict";
  at.exports = /^#!(.*)/;
});
var dt = l((Le, pt) => {
  "use strict";
  var Qt = lt();
  pt.exports = (t = "") => {
    let e = t.match(Qt);
    if (!e)
      return null;
    let [n, r] = e[0].replace(/#! ?/, "").split(" "), s = n.split("/").pop();
    return s === "env" ? r : r ? `${s} ${r}` : s;
  };
});
var ht = l((je, ft) => {
  "use strict";
  var O = h("fs"), Zt = dt();
  function te(t) {
    let n = Buffer.alloc(150), r;
    try {
      r = O.openSync(t, "r"), O.readSync(r, n, 0, 150, 0), O.closeSync(r);
    } catch {
    }
    return Zt(n.toString());
  }
  ft.exports = te;
});
var wt = l((Fe, Et) => {
  "use strict";
  var ee = h("path"), mt = ct(), gt = ut(), ne = ht(), re = process.platform === "win32", se = /\.(?:com|exe)$/i, oe = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function ie(t) {
    t.file = mt(t);
    let e = t.file && ne(t.file);
    return e ? (t.args.unshift(t.file), t.command = e, mt(t)) : t.file;
  }
  function ce(t) {
    if (!re)
      return t;
    let e = ie(t), n = !se.test(e);
    if (t.options.forceShell || n) {
      let r = oe.test(e);
      t.command = ee.normalize(t.command), t.command = gt.command(t.command), t.args = t.args.map((o) => gt.argument(o, r));
      let s = [t.command].concat(t.args).join(" ");
      t.args = ["/d", "/s", "/c", `"${s}"`], t.command = process.env.comspec || "cmd.exe", t.options.windowsVerbatimArguments = true;
    }
    return t;
  }
  function ue(t, e, n) {
    e && !Array.isArray(e) && (n = e, e = null), e = e ? e.slice(0) : [], n = Object.assign({}, n);
    let r = {
      command: t,
      args: e,
      options: n,
      file: void 0,
      original: {
        command: t,
        args: e
      }
    };
    return n.shell ? r : ce(r);
  }
  Et.exports = ue;
});
var bt = l((ze, vt) => {
  "use strict";
  var S = process.platform === "win32";
  function k(t, e) {
    return Object.assign(new Error(`${e} ${t.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${e} ${t.command}`,
      path: t.command,
      spawnargs: t.args
    });
  }
  function ae(t, e) {
    if (!S)
      return;
    let n = t.emit;
    t.emit = function(r, s) {
      if (r === "exit") {
        let o = xt(s, e, "spawn");
        if (o)
          return n.call(t, "error", o);
      }
      return n.apply(t, arguments);
    };
  }
  function xt(t, e) {
    return S && t === 1 && !e.file ? k(e.original, "spawn") : null;
  }
  function le(t, e) {
    return S && t === 1 && !e.file ? k(e.original, "spawnSync") : null;
  }
  vt.exports = {
    hookChildProcess: ae,
    verifyENOENT: xt,
    verifyENOENTSync: le,
    notFoundError: k
  };
});
var Ct = l((He, E) => {
  "use strict";
  var yt = h("child_process"), T = wt(), A = bt();
  function _t(t, e, n) {
    let r = T(t, e, n), s = yt.spawn(r.command, r.args, r.options);
    return A.hookChildProcess(s, r), s;
  }
  function pe(t, e, n) {
    let r = T(t, e, n), s = yt.spawnSync(r.command, r.args, r.options);
    return s.error = s.error || A.verifyENOENTSync(s.status, r), s;
  }
  E.exports = _t;
  E.exports.spawn = _t;
  E.exports.sync = pe;
  E.exports._parse = T;
  E.exports._enoent = A;
});
var Lt = /^path$/i;
var q = { key: "PATH", value: "" };
function jt(t) {
  for (let e in t) {
    if (!Object.prototype.hasOwnProperty.call(t, e) || !Lt.test(e))
      continue;
    let n = t[e];
    return n ? { key: e, value: n } : q;
  }
  return q;
}
function Ft(t, e) {
  let n = e.value.split(N), r = t, s;
  do
    n.push(qt(r, "node_modules", ".bin")), s = r, r = It(r);
  while (r !== s);
  return { key: e.key, value: n.join(N) };
}
function I(t, e) {
  let n = {
    ...process.env,
    ...e
  }, r = Ft(t, jt(n));
  return n[r.key] = r.value, n;
}
var L = (t) => {
  let e = t.length, n = new zt(), r = () => {
    --e === 0 && n.emit("end");
  };
  for (let s of t)
    s.pipe(n, { end: false }), s.on("end", r);
  return n;
};
var Pt = Nt(Ct(), 1);
var x = class extends Error {
  result;
  output;
  get exitCode() {
    if (this.result.exitCode !== null)
      return this.result.exitCode;
  }
  constructor(e, n) {
    super(`Process exited with non-zero status (${e.exitCode})`), this.result = e, this.output = n;
  }
};
var ge = {
  timeout: void 0,
  persist: false
};
var Ee = {
  windowsHide: true
};
function we(t, e) {
  return {
    command: fe(t),
    args: e ?? []
  };
}
function xe(t) {
  let e = new AbortController();
  for (let n of t) {
    if (n.aborted)
      return e.abort(), n;
    let r = () => {
      e.abort(n.reason);
    };
    n.addEventListener("abort", r, {
      signal: e.signal
    });
  }
  return e.signal;
}
var R = class {
  _process;
  _aborted = false;
  _options;
  _command;
  _args;
  _resolveClose;
  _processClosed;
  _thrownError;
  get process() {
    return this._process;
  }
  get pid() {
    return this._process?.pid;
  }
  get exitCode() {
    if (this._process && this._process.exitCode !== null)
      return this._process.exitCode;
  }
  constructor(e, n, r) {
    this._options = {
      ...ge,
      ...r
    }, this._command = e, this._args = n ?? [], this._processClosed = new Promise((s) => {
      this._resolveClose = s;
    });
  }
  kill(e) {
    return this._process?.kill(e) === true;
  }
  get aborted() {
    return this._aborted;
  }
  get killed() {
    return this._process?.killed === true;
  }
  pipe(e, n, r) {
    return be(e, n, {
      ...r,
      stdin: this
    });
  }
  async *[Symbol.asyncIterator]() {
    let e = this._process;
    if (!e)
      return;
    let n = [];
    this._streamErr && n.push(this._streamErr), this._streamOut && n.push(this._streamOut);
    let r = L(n), s = me.createInterface({
      input: r
    });
    for await (let o of s)
      yield o.toString();
    if (await this._processClosed, e.removeAllListeners(), this._thrownError)
      throw this._thrownError;
    if (this._options?.throwOnError && this.exitCode !== 0 && this.exitCode !== void 0)
      throw new x(this);
  }
  async _waitForOutput() {
    let e = this._process;
    if (!e)
      throw new Error("No process was started");
    let n = "", r = "";
    if (this._streamOut)
      for await (let o of this._streamOut)
        r += o.toString();
    if (this._streamErr)
      for await (let o of this._streamErr)
        n += o.toString();
    if (await this._processClosed, this._options?.stdin && await this._options.stdin, e.removeAllListeners(), this._thrownError)
      throw this._thrownError;
    let s = {
      stderr: n,
      stdout: r,
      exitCode: this.exitCode
    };
    if (this._options.throwOnError && this.exitCode !== 0 && this.exitCode !== void 0)
      throw new x(this, s);
    return s;
  }
  then(e, n) {
    return this._waitForOutput().then(e, n);
  }
  _streamOut;
  _streamErr;
  spawn() {
    let e = he(), n = this._options, r = {
      ...Ee,
      ...n.nodeOptions
    }, s = [];
    this._resetState(), n.timeout !== void 0 && s.push(AbortSignal.timeout(n.timeout)), n.signal !== void 0 && s.push(n.signal), n.persist === true && (r.detached = true), s.length > 0 && (r.signal = xe(s)), r.env = I(e, r.env);
    let { command: o, args: i } = we(this._command, this._args), a = (0, Pt._parse)(o, i, r), c = de(
      a.command,
      a.args,
      a.options
    );
    if (c.stderr && (this._streamErr = c.stderr), c.stdout && (this._streamOut = c.stdout), this._process = c, c.once("error", this._onError), c.once("close", this._onClose), n.stdin !== void 0 && c.stdin && n.stdin.process) {
      let { stdout: u } = n.stdin.process;
      u && u.pipe(c.stdin);
    }
  }
  _resetState() {
    this._aborted = false, this._processClosed = new Promise((e) => {
      this._resolveClose = e;
    }), this._thrownError = void 0;
  }
  _onError = (e) => {
    if (e.name === "AbortError" && (!(e.cause instanceof Error) || e.cause.name !== "TimeoutError")) {
      this._aborted = true;
      return;
    }
    this._thrownError = e;
  };
  _onClose = () => {
    this._resolveClose && this._resolveClose();
  };
};
var ve = (t, e, n) => {
  let r = new R(t, e, n);
  return r.spawn(), r;
};
var be = ve;

// node_modules/.pnpm/nypm@0.6.2/node_modules/nypm/dist/shared/nypm.CLjaS_sz.mjs
import { existsSync } from "node:fs";
import { readFile } from "node:fs/promises";
async function findup(cwd2, match, options = {}) {
  const segments = normalize(cwd2).split("/");
  while (segments.length > 0) {
    const path4 = segments.join("/") || "/";
    const result = await match(path4);
    if (result || !options.includeParentDirs) {
      return result;
    }
    segments.pop();
  }
}
function cached(fn) {
  let v;
  return () => {
    if (v === void 0) {
      v = fn().then((r) => {
        v = r;
        return v;
      });
    }
    return v;
  };
}
var hasCorepack = cached(async () => {
  if (globalThis.process?.versions?.webcontainer) {
    return false;
  }
  try {
    const { exitCode } = await ve("corepack", ["--version"]);
    return exitCode === 0;
  } catch {
    return false;
  }
});
async function executeCommand(command, args, options = {}) {
  const xArgs = command === "npm" || command === "bun" || command === "deno" || !await hasCorepack() ? [command, args] : ["corepack", [command, ...args]];
  const { exitCode, stdout, stderr } = await ve(xArgs[0], xArgs[1], {
    nodeOptions: {
      cwd: resolve(options.cwd || process.cwd()),
      env: options.env,
      stdio: options.silent ? "pipe" : "inherit"
    }
  });
  if (exitCode !== 0) {
    throw new Error(
      `\`${xArgs.flat().join(" ")}\` failed.${options.silent ? ["", stdout, stderr].join("\n") : ""}`
    );
  }
}
var NO_PACKAGE_MANAGER_DETECTED_ERROR_MSG = "No package manager auto-detected.";
async function resolveOperationOptions(options = {}) {
  const cwd2 = options.cwd || process.cwd();
  const env = { ...process.env, ...options.env };
  const packageManager2 = (typeof options.packageManager === "string" ? packageManagers.find((pm) => pm.name === options.packageManager) : options.packageManager) || await detectPackageManager(options.cwd || process.cwd());
  if (!packageManager2) {
    throw new Error(NO_PACKAGE_MANAGER_DETECTED_ERROR_MSG);
  }
  return {
    cwd: cwd2,
    env,
    silent: options.silent ?? false,
    packageManager: packageManager2,
    dev: options.dev ?? false,
    workspace: options.workspace,
    global: options.global ?? false,
    dry: options.dry ?? false
  };
}
function parsePackageManagerField(packageManager2) {
  const [name, _version] = (packageManager2 || "").split("@");
  const [version, buildMeta] = _version?.split("+") || [];
  if (name && name !== "-" && /^(@[a-z0-9-~][a-z0-9-._~]*\/)?[a-z0-9-~][a-z0-9-._~]*$/.test(name)) {
    return { name, version, buildMeta };
  }
  const sanitized = name.replace(/\W+/g, "");
  const warnings = [
    `Abnormal characters found in \`packageManager\` field, sanitizing from \`${name}\` to \`${sanitized}\``
  ];
  return {
    name: sanitized,
    version,
    buildMeta,
    warnings
  };
}
var packageManagers = [
  {
    name: "npm",
    command: "npm",
    lockFile: "package-lock.json"
  },
  {
    name: "pnpm",
    command: "pnpm",
    lockFile: "pnpm-lock.yaml",
    files: ["pnpm-workspace.yaml"]
  },
  {
    name: "bun",
    command: "bun",
    lockFile: ["bun.lockb", "bun.lock"]
  },
  {
    name: "yarn",
    command: "yarn",
    lockFile: "yarn.lock",
    files: [".yarnrc.yml"]
  },
  {
    name: "deno",
    command: "deno",
    lockFile: "deno.lock",
    files: ["deno.json"]
  }
];
async function detectPackageManager(cwd2, options = {}) {
  const detected = await findup(
    resolve(cwd2 || "."),
    async (path4) => {
      if (!options.ignorePackageJSON) {
        const packageJSONPath = join(path4, "package.json");
        if (existsSync(packageJSONPath)) {
          const packageJSON = JSON.parse(
            await readFile(packageJSONPath, "utf8")
          );
          if (packageJSON?.packageManager) {
            const {
              name,
              version = "0.0.0",
              buildMeta,
              warnings
            } = parsePackageManagerField(packageJSON.packageManager);
            if (name) {
              const majorVersion = version.split(".")[0];
              const packageManager2 = packageManagers.find(
                (pm) => pm.name === name && pm.majorVersion === majorVersion
              ) || packageManagers.find((pm) => pm.name === name);
              return {
                name,
                command: name,
                version,
                majorVersion,
                buildMeta,
                warnings,
                files: packageManager2?.files,
                lockFile: packageManager2?.lockFile
              };
            }
          }
        }
        const denoJSONPath = join(path4, "deno.json");
        if (existsSync(denoJSONPath)) {
          return packageManagers.find((pm) => pm.name === "deno");
        }
      }
      if (!options.ignoreLockFile) {
        for (const packageManager2 of packageManagers) {
          const detectionsFiles = [
            packageManager2.lockFile,
            packageManager2.files
          ].flat().filter(Boolean);
          if (detectionsFiles.some((file) => existsSync(resolve(path4, file)))) {
            return {
              ...packageManager2
            };
          }
        }
      }
    },
    {
      includeParentDirs: options.includeParentDirs ?? true
    }
  );
  if (!detected && !options.ignoreArgv) {
    const scriptArg = process.argv[1];
    if (scriptArg) {
      for (const packageManager2 of packageManagers) {
        const re = new RegExp(`[/\\\\]\\.?${packageManager2.command}`);
        if (re.test(scriptArg)) {
          return packageManager2;
        }
      }
    }
  }
  return detected;
}
async function installDependencies(options = {}) {
  const resolvedOptions = await resolveOperationOptions(options);
  const pmToFrozenLockfileInstallCommand = {
    npm: ["ci"],
    yarn: ["install", "--immutable"],
    bun: ["install", "--frozen-lockfile"],
    pnpm: ["install", "--frozen-lockfile"],
    deno: ["install", "--frozen"]
  };
  const commandArgs = options.frozenLockFile ? pmToFrozenLockfileInstallCommand[resolvedOptions.packageManager.name] : ["install"];
  if (!resolvedOptions.dry) {
    await executeCommand(resolvedOptions.packageManager.command, commandArgs, {
      cwd: resolvedOptions.cwd,
      silent: resolvedOptions.silent
    });
  }
  return {
    exec: {
      command: resolvedOptions.packageManager.command,
      args: commandArgs
    }
  };
}

// src/utils/cli/postinstall/pnpm.ts
async function pnpmIgnored(root) {
  const pnpmVersion = (await ve(`pnpm`, ["-v"], { nodeOptions: { cwd: root } })).stdout.trim();
  const [major] = pnpmVersion.split(".").map(Number);
  if (major && major >= 10) {
    const detect2 = (await ve("pnpm", ["ignored-builds"], { nodeOptions: { cwd: root } })).stdout;
    if (detect2.startsWith("Automatically ignored builds during installation:\n  None")) {
      return;
    }
    return detect2;
  }
}
async function pnpm(root) {
  const detect2 = await pnpmIgnored(root);
  if (detect2) {
    console.warn(detect2);
  }
}

// src/utils/cli/preinstall/yarn.ts
import { appendFileSync } from "node:fs";
import { resolve as resolve2 } from "node:path";
var templateToAppend = `
packageExtensions:
  unplugin-vue-router@*:
    dependencies:
      "@vue/compiler-sfc": "*"
`;
async function yarnFile(root) {
  const pnpmVersion = (await ve("yarn", ["-v"], { nodeOptions: { cwd: root } })).stdout.trim();
  const [major] = pnpmVersion.split(".").map(Number);
  if (major && major >= 2) {
    appendFileSync(resolve2(root, ".yarnrc.yml"), templateToAppend);
  }
}
async function yarn(root) {
  await yarnFile(root);
}

// src/utils/installDependencies.ts
var userAgent = process.env.npm_config_user_agent ?? "";
var packageManager = /bun/.test(userAgent) ? "bun" : /pnpm/.test(userAgent) ? "pnpm" : "npm";
async function installDependencies2(root = process.cwd(), manager = packageManager) {
  if (manager === "yarn") {
    await yarn(root);
  }
  await installDependencies({
    packageManager: manager,
    cwd: root,
    silent: true
  }).catch(() => {
    console.error(
      `Failed to install dependencies using ${manager}.`
    );
  });
  if (manager === "pnpm") {
    await pnpm(root);
  }
}

// src/utils/prompts.ts
import validate from "validate-npm-package-name";
var promptOptions = {
  onCancel: () => {
    throw new Error(red("\u2716") + " Operation cancelled");
  }
};
async function initPrompts(context) {
  if (context.usePreset) {
    context = {
      ...context,
      ...presets[context.usePreset]
    };
  }
  const answers = await prompts([
    {
      name: "projectName",
      type: "text",
      message: "Project name:",
      initial: "vuetify-project",
      format: (v) => v.trim(),
      validate: (v) => {
        const { errors, warnings, validForNewPackages: isValid } = validate(String(v).trim());
        const error = isValid ? null : errors ? errors[0] : warnings[0];
        if (!isValid) {
          return `Package ${error}`;
        }
        return true;
      }
    },
    {
      name: "canOverwrite",
      active: "Yes",
      inactive: "No",
      initial: false,
      type: (_, { projectName }) => {
        const projectPath = join2(context.cwd, projectName);
        return !existsSync2(projectPath) || readdirSync(projectPath).length === 0 ? null : "toggle";
      },
      onState(a) {
        if (!a.value) {
          console.error("\n\n", red("\u2716") + " Target directory exists and is not empty.");
          process.exit(1);
        }
      },
      message: (prev) => `The project path: ${resolve3(context.cwd, prev)} already exists, would you like to overwrite this directory?`
    },
    {
      name: "usePreset",
      type: context.usePreset ? null : "select",
      message: "Which preset would you like to install?",
      initial: 1,
      choices: [
        { title: "Barebones (Only Vue & Vuetify)", value: "default" },
        { title: "Default (Adds routing, ESLint & SASS variables)", value: "base" },
        { title: "Recommended (Everything from Default. Adds auto importing, layouts & pinia)", value: "essentials" },
        { title: "Nuxt Barebones (Only Vuetify)", value: "nuxt-default" },
        { title: "Nuxt Default (Adds Nuxt ESLint & SASS variables)", value: "nuxt-base" },
        { title: "Nuxt Recommended (Everything from Default. Enables auto importing & layouts)", value: "nuxt-essentials" }
      ]
    },
    {
      name: "useTypeScript",
      type: (usePreset) => {
        const p = context.usePreset ?? usePreset;
        return p.startsWith("nuxt-") || context.useTypeScript ? null : "toggle";
      },
      message: "Use TypeScript?",
      active: "Yes",
      inactive: "No",
      initial: false
    },
    {
      name: "usePackageManager",
      type: (_, { usePreset }) => {
        const p = context.usePreset ?? usePreset;
        return p.startsWith("nuxt-") ? null : "select";
      },
      message: "Would you like to install dependencies with yarn, npm, pnpm, or bun?",
      initial: packageManager === "bun" ? 3 : 0,
      choices: [
        { title: "pnpm", value: "pnpm" },
        { title: "npm", value: "npm" },
        { title: "yarn", value: "yarn" },
        { title: "bun", value: "bun" },
        { title: "none", value: null }
      ]
    },
    {
      name: "installDependencies",
      type: (_, { usePreset }) => {
        const p = context.usePreset ?? usePreset;
        return p.startsWith("nuxt-") || context.installDependencies ? null : "toggle";
      },
      message: "Install Dependencies?",
      active: "Yes",
      inactive: "No",
      initial: "Yes"
    },
    {
      name: "useNuxtModule",
      type: (_, { usePreset }) => {
        const p = context.usePreset ?? usePreset;
        return p.startsWith("nuxt-") ? "toggle" : null;
      },
      message: "Use vuetify-nuxt-module?",
      active: "Yes",
      inactive: "No",
      initial: "Yes"
    },
    {
      name: "useNuxtSSR",
      type: (_, { usePreset }) => {
        const p = context.usePreset ?? usePreset;
        return p.startsWith("nuxt-") ? "toggle" : null;
      },
      message: "Enable Nuxt SSR?",
      active: "Yes",
      inactive: "No",
      initial: "Yes"
    },
    {
      name: "useNuxtSSRClientHints",
      type: (useNuxtSSR, { usePreset, useNuxtModule }) => {
        const p = context.usePreset ?? usePreset;
        if (!p.startsWith("nuxt-")) {
          return null;
        }
        return useNuxtModule && useNuxtSSR ? "toggle" : null;
      },
      message: "Enable Nuxt SSR Http Client Hints?",
      active: "Yes",
      inactive: "No",
      initial: "Yes"
    }
  ], promptOptions);
  return {
    ...context,
    ...answers
  };
}

// src/utils/nonInteractivePrompts.ts
import { join as join3, resolve as resolve4 } from "node:path";
import { existsSync as existsSync3, readdirSync as readdirSync2 } from "node:fs";
import { red as red2 } from "kolorist";
function resolveNonInteractiveContext(context) {
  if (context.usePreset) {
    context = {
      ...context,
      ...presets[context.usePreset]
    };
  }
  const projectName = context.projectName || "vuetify-project";
  const projectPath = join3(context.cwd, projectName);
  const directoryExists = existsSync3(projectPath);
  const directoryNotEmpty = directoryExists && readdirSync2(projectPath).length > 0;
  if (directoryNotEmpty && !context.canOverwrite) {
    console.error("\n\n", red2("\u2716") + ` Target directory ${resolve4(context.cwd, projectName)} exists and is not empty.`);
    console.error("Use --force or --overwrite flag to overwrite the directory.");
    process.exit(1);
  }
  let useTypeScript = context.useTypeScript;
  if (useTypeScript === void 0) {
    const preset = context.usePreset;
    useTypeScript = preset ? preset.startsWith("nuxt-") : false;
  }
  let usePackageManager = context.usePackageManager;
  if (usePackageManager === void 0) {
    const preset = context.usePreset;
    if (!preset || !preset.startsWith("nuxt-")) {
      usePackageManager = packageManager;
    }
  }
  let installDependencies3 = context.installDependencies;
  if (installDependencies3 === void 0) {
    const preset = context.usePreset;
    installDependencies3 = preset ? !preset.startsWith("nuxt-") : true;
  }
  const usePreset = context.usePreset || "default";
  const useNuxtModule = context.useNuxtModule;
  const useNuxtSSR = context.useNuxtSSR;
  const useNuxtSSRClientHints = context.useNuxtSSRClientHints;
  return {
    cwd: context.cwd,
    projectName,
    canOverwrite: context.canOverwrite || false,
    useTypeScript: useTypeScript || false,
    usePackageManager: usePackageManager || "npm",
    installDependencies: installDependencies3 || false,
    usePreset,
    useNuxtModule: useNuxtModule || false,
    useNuxtSSR: useNuxtSSR || false,
    useNuxtSSRClientHints: useNuxtSSRClientHints || false
  };
}

// package.json
var package_default = {
  name: "create-vuetify",
  version: "2.7.0",
  author: "Elijah Kotyluk <elijah@elijahkotyluk.com>",
  license: "MIT",
  type: "module",
  bin: {
    "create-vuetify": "bin/index.js"
  },
  files: [
    "bin/index.js",
    "template",
    "dist"
  ],
  repository: {
    type: "git",
    url: "git+https://github.com/vuetifyjs/create.git"
  },
  bugs: {
    url: "https://github.com/vuetifyjs/create/issues"
  },
  keywords: [
    "vuetify",
    "vue",
    "vue3",
    "ui",
    "scaffolding",
    "cli",
    "template",
    "create",
    "boilerplate",
    "starter",
    "typescript",
    "javascript",
    "vite",
    "pinia",
    "vue-router",
    "nuxt",
    "material-design",
    "material-ui",
    "components"
  ],
  scripts: {
    build: "node ./scripts/build.js",
    start: "node ./index.js",
    dev: "node --run build && node --run start",
    lint: "eslint --fix .",
    prepublishOnly: "node --run build",
    release: "bumpp"
  },
  dependencies: {
    kolorist: "^1.8.0",
    magicast: "^0.3.5",
    minimist: "^1.2.8",
    "package-manager-detector": "^1.3.0",
    prompts: "^2.4.2",
    tinyexec: "^1.0.1",
    "validate-npm-package-name": "^6.0.2"
  },
  devDependencies: {
    "@types/minimist": "^1.2.5",
    "@types/node": "^22.18.5",
    "@types/prompts": "^2.4.9",
    "@types/validate-npm-package-name": "^4.0.2",
    bumpp: "^10.2.3",
    esbuild: "^0.25.9",
    eslint: "^9.35.0",
    "eslint-config-vuetify": "^4.2.0",
    nypm: "^0.6.2",
    typescript: "^5.9.2"
  },
  packageManager: "pnpm@9.15.9"
};

// src/utils/cli/helpText.ts
function getHelpText() {
  return `
Usage: create-vuetify [project-name] [options]

Options:
  -p, --preset <preset>              Choose a preset (base, default, essentials, nuxt-base, nuxt-default, nuxt-essentials)
  --ts, --typescript                 Use TypeScript
  --pm, --package-manager <manager>  Package manager to use (npm, pnpm, yarn, bun, none)
  -i, --install                      Install dependencies
  -f, --force, --overwrite           Overwrite existing directory
  --nuxt-module                      Use vuetify-nuxt-module (for Nuxt presets)
  --nuxt-ssr, --ssr                  Enable Nuxt SSR (for Nuxt presets)
  --nuxt-ssr-client-hints            Enable Nuxt SSR Client Hints (for Nuxt presets)
  -h, --help                         Show help
  -v, --version                      Show version

Examples:
  create-vuetify                                          # Interactive mode
  create-vuetify my-app --preset default --typescript     # Non-interactive with TypeScript
  create-vuetify my-app --preset nuxt-essentials --ssr    # Nuxt project with SSR
  create-vuetify my-app --force --install --pm pnpm       # Force overwrite and install with pnpm

Presets:
  default      - Barebones (Only Vue & Vuetify)
  base         - Default (Adds routing, ESLint & SASS variables)
  essentials   - Recommended (Everything from Default. Adds auto importing, layouts & pinia)
  nuxt-base    - Nuxt Default (Adds Nuxt ESLint & SASS variables)
  nuxt-default - Nuxt Barebones (Only Vuetify)
  nuxt-essentials - Nuxt Recommended (Everything from Default. Enables auto importing & layouts)
`.trim();
}
function getVersionText() {
  return `${package_default.version}`;
}

// src/utils/cli/parseArgs.ts
import minimist from "minimist";
var validPresets = ["base", "default", "essentials", "nuxt-base", "nuxt-default", "nuxt-essentials"];
var validPackageManagers = ["npm", "pnpm", "yarn", "bun", "none"];
function parseCliArgs(args) {
  const argv = minimist(args, {
    alias: {
      typescript: ["ts"],
      preset: ["p"],
      packageManager: ["pm", "package-manager"],
      installDependencies: ["install", "i"],
      overwrite: ["force", "f"],
      nuxtModule: ["nuxt-module"],
      nuxtSSR: ["nuxt-ssr", "ssr"],
      nuxtSSRClientHints: ["nuxt-ssr-client-hints", "client-hints"],
      help: ["h"],
      version: ["v"]
    },
    boolean: [
      "typescript",
      "installDependencies",
      "overwrite",
      "nuxtModule",
      "nuxtSSR",
      "nuxtSSRClientHints",
      "help",
      "version"
    ],
    string: [
      "preset",
      "packageManager"
    ]
  });
  if (argv.preset && !validPresets.includes(argv.preset)) {
    throw new Error(`'${argv.preset}' is not a valid preset. Valid presets are: ${validPresets.join(", ")}.`);
  }
  if (argv.packageManager && !validPackageManagers.includes(argv.packageManager)) {
    throw new Error(`'${argv.packageManager}' is not a valid package manager. Valid options are: ${validPackageManagers.join(", ")}.`);
  }
  const projectName = argv._[0];
  return {
    projectName,
    preset: argv.preset,
    typescript: argv.typescript,
    packageManager: argv.packageManager,
    installDependencies: argv.installDependencies,
    overwrite: argv.overwrite,
    nuxtModule: argv.nuxtModule,
    nuxtSSR: argv.nuxtSSR,
    nuxtSSRClientHints: argv.nuxtSSRClientHints,
    help: argv.help,
    version: argv.version
  };
}
function cliOptionsToContext(cliOptions, cwd2) {
  return {
    cwd: cwd2,
    projectName: cliOptions.projectName || "vuetify-project",
    useTypeScript: cliOptions.typescript,
    usePreset: cliOptions.preset ?? "default",
    usePackageManager: cliOptions.packageManager === "none" ? void 0 : cliOptions.packageManager,
    installDependencies: cliOptions.installDependencies,
    canOverwrite: cliOptions.overwrite ?? false,
    useNuxtModule: cliOptions.nuxtModule ?? true,
    useNuxtSSR: cliOptions.nuxtSSR ?? true,
    useNuxtSSRClientHints: cliOptions.nuxtSSRClientHints ?? (cliOptions.nuxtModule && cliOptions.nuxtSSR)
  };
}

// src/index.ts
import { red as red3 } from "kolorist";

// src/utils/banner.ts
import { blue } from "kolorist";
function supportsColor() {
  const testText = "test";
  const coloredText = blue(testText);
  return coloredText !== testText;
}
function createBanner() {
  if (!supportsColor()) {
    return createPlainBanner();
  }
  return "\x1B[38;2;22;151;246mV\x1B[39m\x1B[38;2;22;147;242mu\x1B[39m\x1B[38;2;22;144;238me\x1B[39m\x1B[38;2;22;140;234mt\x1B[39m\x1B[38;2;23;136;229mi\x1B[39m\x1B[38;2;23;133;225mf\x1B[39m\x1B[38;2;23;129;221my\x1B[39m\x1B[38;2;23;125;217m.\x1B[39m\x1B[38;2;23;121;213mj\x1B[39m\x1B[38;2;23;118;209ms\x1B[39m \x1B[38;2;24;114;204m-\x1B[39m \x1B[38;2;24;110;200mM\x1B[39m\x1B[38;2;24;107;196ma\x1B[39m\x1B[38;2;24;103;192mt\x1B[39m\x1B[38;2;32;110;197me\x1B[39m\x1B[38;2;39;118;202mr\x1B[39m\x1B[38;2;47;125;207mi\x1B[39m\x1B[38;2;54;132;211ma\x1B[39m\x1B[38;2;62;140;216ml\x1B[39m \x1B[38;2;70;147;221mC\x1B[39m\x1B[38;2;77;154;226mo\x1B[39m\x1B[38;2;85;161;231mm\x1B[39m\x1B[38;2;93;169;236mp\x1B[39m\x1B[38;2;100;176;240mo\x1B[39m\x1B[38;2;108;183;245mn\x1B[39m\x1B[38;2;115;191;250me\x1B[39m\x1B[38;2;123;198;255mn\x1B[39m\x1B[38;2;126;199;255mt\x1B[39m \x1B[38;2;129;201;255mF\x1B[39m\x1B[38;2;133;202;255mr\x1B[39m\x1B[38;2;136;204;255ma\x1B[39m\x1B[38;2;139;205;255mm\x1B[39m\x1B[38;2;142;207;255me\x1B[39m\x1B[38;2;145;208;255mw\x1B[39m\x1B[38;2;149;210;255mo\x1B[39m\x1B[38;2;152;211;255mr\x1B[39m\x1B[38;2;155;212;255mk\x1B[39m \x1B[38;2;158;214;255mf\x1B[39m\x1B[38;2;161;215;255mo\x1B[39m\x1B[38;2;164;217;255mr\x1B[39m \x1B[38;2;168;218;255mV\x1B[39m\x1B[38;2;171;220;255mu\x1B[39m\x1B[38;2;174;221;255me\x1B[39m";
}
function createPlainBanner() {
  return "Vuetify - Vue Component Framework";
}

// src/utils/deepMerge.ts
var isObject = (v) => {
  return v === Object(v) && v !== null && !Array.isArray(v);
};
var deepMerge = (...sources) => sources.reduce((acc, curr) => {
  for (const key of Object.keys(curr)) {
    if (Array.isArray(acc[key]) && Array.isArray(curr[key])) {
      acc[key] = Array.from(new Set(acc[key].concat(curr[key])));
    } else if (isObject(acc[key]) && isObject(curr[key])) {
      acc[key] = deepMerge(acc[key], curr[key]);
    } else {
      acc[key] = curr[key];
    }
  }
  return acc;
}, {});

// src/utils/renderTemplate.ts
import { copyFileSync, mkdirSync, readdirSync as readdirSync3, readFileSync, statSync, writeFileSync, existsSync as existsSync4 } from "node:fs";
import { basename as basename2, dirname as dirname2, resolve as resolve5 } from "node:path";
function mergePkg(source, destination) {
  const target = existsSync4(destination) ? JSON.parse(readFileSync(destination, "utf8")) : {};
  const src = JSON.parse(readFileSync(source, "utf8"));
  const mergedPkg = deepMerge(target, src);
  const keysToSort = ["devDependencies", "dependencies"];
  for (const k of keysToSort) {
    if (mergedPkg[k]) {
      mergedPkg[k] = Object.keys(mergedPkg[k]).toSorted().reduce((a, c) => (a[c] = mergedPkg[k][c], a), {});
    }
  }
  writeFileSync(destination, JSON.stringify(mergedPkg, null, 2) + "\n");
}
function renderDirectory(source, destination) {
  mkdirSync(destination, { recursive: true });
  for (const path4 of readdirSync3(source)) {
    renderTemplate(resolve5(source, path4), resolve5(destination, path4));
  }
}
function renderFile(source, destination) {
  const filename = basename2(source);
  if (filename.startsWith("_")) {
    destination = resolve5(dirname2(destination), filename.replace("_", "."));
  }
  if (filename === "package.json") {
    mergePkg(source, destination);
  } else {
    copyFileSync(source, destination);
  }
}
function renderTemplate(source, destination) {
  if (statSync(source).isDirectory()) {
    renderDirectory(source, destination);
  } else {
    renderFile(source, destination);
  }
}

// src/utils/nuxt/renderNuxtTemplate.ts
import fs3 from "node:fs";
import path3 from "node:path";
import { spawnSync as spawnSync2 } from "node:child_process";

// src/utils/nuxt/utils.ts
import process2 from "node:process";
import path from "node:path";
import { spawnSync } from "node:child_process";
import fs from "node:fs";

// node_modules/.pnpm/package-manager-detector@1.3.0/node_modules/package-manager-detector/dist/commands.mjs
function dashDashArg(agent, agentCommand) {
  return (args) => {
    if (args.length > 1) {
      return [agent, agentCommand, args[0], "--", ...args.slice(1)];
    } else {
      return [agent, agentCommand, args[0]];
    }
  };
}
function denoExecute() {
  return (args) => {
    return ["deno", "run", `npm:${args[0]}`, ...args.slice(1)];
  };
}
var npm = {
  "agent": ["npm", 0],
  "run": dashDashArg("npm", "run"),
  "install": ["npm", "i", 0],
  "frozen": ["npm", "ci", 0],
  "global": ["npm", "i", "-g", 0],
  "add": ["npm", "i", 0],
  "upgrade": ["npm", "update", 0],
  "upgrade-interactive": null,
  "execute": ["npx", 0],
  "execute-local": ["npx", 0],
  "uninstall": ["npm", "uninstall", 0],
  "global_uninstall": ["npm", "uninstall", "-g", 0]
};
var yarn2 = {
  "agent": ["yarn", 0],
  "run": ["yarn", "run", 0],
  "install": ["yarn", "install", 0],
  "frozen": ["yarn", "install", "--frozen-lockfile", 0],
  "global": ["yarn", "global", "add", 0],
  "add": ["yarn", "add", 0],
  "upgrade": ["yarn", "upgrade", 0],
  "upgrade-interactive": ["yarn", "upgrade-interactive", 0],
  "execute": ["npx", 0],
  "execute-local": dashDashArg("yarn", "exec"),
  "uninstall": ["yarn", "remove", 0],
  "global_uninstall": ["yarn", "global", "remove", 0]
};
var yarnBerry = {
  ...yarn2,
  "frozen": ["yarn", "install", "--immutable", 0],
  "upgrade": ["yarn", "up", 0],
  "upgrade-interactive": ["yarn", "up", "-i", 0],
  "execute": ["yarn", "dlx", 0],
  "execute-local": ["yarn", "exec", 0],
  // Yarn 2+ removed 'global', see https://github.com/yarnpkg/berry/issues/821
  "global": ["npm", "i", "-g", 0],
  "global_uninstall": ["npm", "uninstall", "-g", 0]
};
var pnpm2 = {
  "agent": ["pnpm", 0],
  "run": ["pnpm", "run", 0],
  "install": ["pnpm", "i", 0],
  "frozen": ["pnpm", "i", "--frozen-lockfile", 0],
  "global": ["pnpm", "add", "-g", 0],
  "add": ["pnpm", "add", 0],
  "upgrade": ["pnpm", "update", 0],
  "upgrade-interactive": ["pnpm", "update", "-i", 0],
  "execute": ["pnpm", "dlx", 0],
  "execute-local": ["pnpm", "exec", 0],
  "uninstall": ["pnpm", "remove", 0],
  "global_uninstall": ["pnpm", "remove", "--global", 0]
};
var bun = {
  "agent": ["bun", 0],
  "run": ["bun", "run", 0],
  "install": ["bun", "install", 0],
  "frozen": ["bun", "install", "--frozen-lockfile", 0],
  "global": ["bun", "add", "-g", 0],
  "add": ["bun", "add", 0],
  "upgrade": ["bun", "update", 0],
  "upgrade-interactive": ["bun", "update", 0],
  "execute": ["bun", "x", 0],
  "execute-local": ["bun", "x", 0],
  "uninstall": ["bun", "remove", 0],
  "global_uninstall": ["bun", "remove", "-g", 0]
};
var deno = {
  "agent": ["deno", 0],
  "run": ["deno", "task", 0],
  "install": ["deno", "install", 0],
  "frozen": ["deno", "install", "--frozen", 0],
  "global": ["deno", "install", "-g", 0],
  "add": ["deno", "add", 0],
  "upgrade": ["deno", "outdated", "--update", 0],
  "upgrade-interactive": ["deno", "outdated", "--update", 0],
  "execute": denoExecute(),
  "execute-local": ["deno", "task", "--eval", 0],
  "uninstall": ["deno", "remove", 0],
  "global_uninstall": ["deno", "uninstall", "-g", 0]
};
var COMMANDS = {
  "npm": npm,
  "yarn": yarn2,
  "yarn@berry": yarnBerry,
  "pnpm": pnpm2,
  // pnpm v6.x or below
  "pnpm@6": {
    ...pnpm2,
    run: dashDashArg("pnpm", "run")
  },
  "bun": bun,
  "deno": deno
};
function resolveCommand(agent, command, args) {
  const value = COMMANDS[agent][command];
  return constructCommand(value, args);
}
function constructCommand(value, args) {
  if (value == null)
    return null;
  const list = typeof value === "function" ? value(args) : value.flatMap((v) => {
    if (typeof v === "number")
      return args;
    return [v];
  });
  return {
    command: list[0],
    args: list.slice(1)
  };
}

// src/utils/nuxt/utils.ts
function detectPkgInfo() {
  const userAgent2 = process2.env.npm_config_user_agent;
  if (!userAgent2) {
    return void 0;
  }
  const pkgSpec = userAgent2.split(" ")[0];
  const pkgSpecArr = pkgSpec.split("/");
  return {
    name: pkgSpecArr[0],
    version: pkgSpecArr[1]
  };
}
function addPackageObject(key, entry, pkg, sort = true) {
  pkg[key] ??= {};
  if (!sort) {
    for (const [name, value] of entry) {
      pkg[key][name] = value;
    }
    return;
  }
  const entries = Object.entries(pkg[key]);
  pkg[key] = {};
  for (const [name, value] of entry) {
    entries.push([name, value]);
  }
  for (const [k, v] of entries.toSorted(([a], [b]) => a.localeCompare(b))) {
    pkg[key][k] = v;
  }
}
function runCommand(pmDetection, command, args, cwd2) {
  let runCommand2 = "npm";
  let runArgs = [command];
  if (pmDetection) {
    const prepare = resolveCommand(pmDetection.name, command, args);
    runCommand2 = prepare.command;
    runArgs = prepare.args;
  }
  const run2 = spawnSync(
    runCommand2,
    runArgs.filter(Boolean),
    {
      cwd: cwd2,
      stdio: ["inherit", "inherit", "pipe"],
      shell: true
    }
  );
  if (run2.error) {
    throw run2.error;
  }
}
function editFile(file, callback, destination) {
  const content = fs.readFileSync(file, "utf8");
  fs.writeFileSync(destination ?? file, callback(content), "utf8");
}
function getPaths(rootPath, templateDir) {
  return [path.join(rootPath, "app"), templateDir];
}

// src/utils/nuxt/versions.ts
var versions = {
  "vuetify": "^3.9.1",
  "typescript": "^5.8.3",
  "vue-tsc": "^3.0.1",
  "sass-embedded": "^1.89.2",
  "@vuetify/loader-shared": "^2.1.0",
  "vite-plugin-vuetify": "^2.1.1",
  "vuetify-nuxt-module": "^0.18.7",
  "upath": "^2.0.1",
  "@mdi/font": "^7.4.47",
  "@nuxt/fonts": "^0.11.4"
};

// node_modules/.pnpm/package-manager-detector@1.3.0/node_modules/package-manager-detector/dist/constants.mjs
var AGENTS = [
  "npm",
  "yarn",
  "yarn@berry",
  "pnpm",
  "pnpm@6",
  "bun",
  "deno"
];
var LOCKS = {
  "bun.lock": "bun",
  "bun.lockb": "bun",
  "deno.lock": "deno",
  "pnpm-lock.yaml": "pnpm",
  "pnpm-workspace.yaml": "pnpm",
  "yarn.lock": "yarn",
  "package-lock.json": "npm",
  "npm-shrinkwrap.json": "npm"
};
var INSTALL_METADATA = {
  "node_modules/.deno/": "deno",
  "node_modules/.pnpm/": "pnpm",
  "node_modules/.yarn-state.yml": "yarn",
  // yarn v2+ (node-modules)
  "node_modules/.yarn_integrity": "yarn",
  // yarn v1
  "node_modules/.package-lock.json": "npm",
  ".pnp.cjs": "yarn",
  // yarn v3+ (pnp)
  ".pnp.js": "yarn",
  // yarn v2 (pnp)
  "bun.lock": "bun",
  "bun.lockb": "bun"
};

// node_modules/.pnpm/package-manager-detector@1.3.0/node_modules/package-manager-detector/dist/detect.mjs
import fs2 from "node:fs/promises";
import path2 from "node:path";
import process3 from "node:process";
async function pathExists(path22, type) {
  try {
    const stat = await fs2.stat(path22);
    return type === "file" ? stat.isFile() : stat.isDirectory();
  } catch {
    return false;
  }
}
function* lookup(cwd2 = process3.cwd()) {
  let directory = path2.resolve(cwd2);
  const { root } = path2.parse(directory);
  while (directory && directory !== root) {
    yield directory;
    directory = path2.dirname(directory);
  }
}
async function parsePackageJson(filepath, onUnknown) {
  return !filepath || !pathExists(filepath, "file") ? null : await handlePackageManager(filepath, onUnknown);
}
async function detect(options = {}) {
  const {
    cwd: cwd2,
    strategies = ["lockfile", "packageManager-field", "devEngines-field"],
    onUnknown
  } = options;
  let stopDir;
  if (typeof options.stopDir === "string") {
    const resolved = path2.resolve(options.stopDir);
    stopDir = (dir) => dir === resolved;
  } else {
    stopDir = options.stopDir;
  }
  for (const directory of lookup(cwd2)) {
    for (const strategy of strategies) {
      switch (strategy) {
        case "lockfile": {
          for (const lock of Object.keys(LOCKS)) {
            if (await pathExists(path2.join(directory, lock), "file")) {
              const name = LOCKS[lock];
              const result = await parsePackageJson(path2.join(directory, "package.json"), onUnknown);
              if (result)
                return result;
              else
                return { name, agent: name };
            }
          }
          break;
        }
        case "packageManager-field":
        case "devEngines-field": {
          const result = await parsePackageJson(path2.join(directory, "package.json"), onUnknown);
          if (result)
            return result;
          break;
        }
        case "install-metadata": {
          for (const metadata of Object.keys(INSTALL_METADATA)) {
            const fileOrDir = metadata.endsWith("/") ? "dir" : "file";
            if (await pathExists(path2.join(directory, metadata), fileOrDir)) {
              const name = INSTALL_METADATA[metadata];
              const agent = name === "yarn" ? isMetadataYarnClassic(metadata) ? "yarn" : "yarn@berry" : name;
              return { name, agent };
            }
          }
          break;
        }
      }
    }
    if (stopDir?.(directory))
      break;
  }
  return null;
}
function getNameAndVer(pkg) {
  const handelVer = (version) => version?.match(/\d+(\.\d+){0,2}/)?.[0] ?? version;
  if (typeof pkg.packageManager === "string") {
    const [name, ver] = pkg.packageManager.replace(/^\^/, "").split("@");
    return { name, ver: handelVer(ver) };
  }
  if (typeof pkg.devEngines?.packageManager?.name === "string") {
    return {
      name: pkg.devEngines.packageManager.name,
      ver: handelVer(pkg.devEngines.packageManager.version)
    };
  }
  return void 0;
}
async function handlePackageManager(filepath, onUnknown) {
  try {
    const pkg = JSON.parse(await fs2.readFile(filepath, "utf8"));
    let agent;
    const nameAndVer = getNameAndVer(pkg);
    if (nameAndVer) {
      const name = nameAndVer.name;
      const ver = nameAndVer.ver;
      let version = ver;
      if (name === "yarn" && ver && Number.parseInt(ver) > 1) {
        agent = "yarn@berry";
        version = "berry";
        return { name, agent, version };
      } else if (name === "pnpm" && ver && Number.parseInt(ver) < 7) {
        agent = "pnpm@6";
        return { name, agent, version };
      } else if (AGENTS.includes(name)) {
        agent = name;
        return { name, agent, version };
      } else {
        return onUnknown?.(pkg.packageManager) ?? null;
      }
    }
  } catch {
  }
  return null;
}
function isMetadataYarnClassic(metadataPath) {
  return metadataPath.endsWith(".yarn_integrity");
}

// src/utils/nuxt/renderNuxtTemplate.ts
import { generateCode, parseModule } from "magicast";
import { addNuxtModule, getDefaultExportOptions } from "magicast/helpers";
async function renderNuxtTemplate(ctx) {
  const {
    cwd: cwd2,
    projectName,
    projectRoot,
    nuxtPreset
  } = ctx;
  const pkgInfo = detectPkgInfo();
  const pkgManager = pkgInfo ? pkgInfo.name : "npm";
  const isYarn1 = pkgManager === "yarn" && pkgInfo?.version.startsWith("1.");
  const customCommand = `npm exec nuxi init ${projectName}`;
  const fullCustomCommand = customCommand.replace("@latest", () => isYarn1 ? "" : "@latest").replace(/^npm exec/, () => {
    if (pkgManager === "pnpm") {
      return "pnpm dlx";
    }
    if (pkgManager === "yarn" && !isYarn1) {
      return "yarn dlx";
    }
    if (pkgManager === "bun") {
      return "bun x";
    }
    return "npm exec";
  });
  const [command, ...args] = fullCustomCommand.split(" ");
  const nuxiCli = spawnSync2(command, args, {
    cwd: cwd2,
    stdio: ["inherit", "inherit", "pipe"],
    shell: true
  });
  if (nuxiCli.error) {
    throw nuxiCli.error;
  }
  configurePackageJson(ctx);
  const pmDetection = await detect({ cwd: projectRoot });
  runCommand(pmDetection, "install", [], projectRoot);
  prepareProject(ctx);
  if (nuxtPreset !== "nuxt-default") {
    runCommand(pmDetection, "execute", ["nuxi", "module", "add", "eslint"], projectRoot);
  }
}
function configurePackageJson({
  projectName,
  projectRoot,
  useNuxtModule,
  nuxtPreset
}) {
  const packageJson = path3.join(projectRoot, "package.json");
  const pkg = JSON.parse(fs3.readFileSync(path3.join(projectRoot, "package.json"), "utf8"));
  pkg.name = projectName;
  const scripts = [
    ["prepare", "nuxt prepare"],
    ["typecheck", "nuxt typecheck"]
  ];
  if (nuxtPreset !== "nuxt-default") {
    scripts.push(["lint", "eslint ."], ["lint:fix", "eslint . --fix"]);
  }
  const dependencies = [
    ["vuetify", versions.vuetify]
  ];
  if (dependencies.length > 0) {
    addPackageObject("dependencies", dependencies, pkg);
  }
  const devDependencies = [
    ["@mdi/font", versions["@mdi/font"]],
    ["@nuxt/fonts", versions["@nuxt/fonts"]],
    ["sass-embedded", versions["sass-embedded"]],
    ["typescript", versions.typescript],
    ["vue-tsc", versions["vue-tsc"]]
  ];
  if (useNuxtModule) {
    devDependencies.push(["vuetify-nuxt-module", versions["vuetify-nuxt-module"]]);
  } else {
    devDependencies.push(["upath", versions["upath"]], ["@vuetify/loader-shared", versions["@vuetify/loader-shared"]], ["vite-plugin-vuetify", versions["vite-plugin-vuetify"]]);
  }
  if (devDependencies.length > 0) {
    addPackageObject("devDependencies", devDependencies, pkg);
  }
  addPackageObject("scripts", scripts, pkg, false);
  fs3.writeFileSync(packageJson, JSON.stringify(pkg, null, 2), "utf8");
}
function configureVuetify(ctx, nuxtConfig) {
  const config = getDefaultExportOptions(nuxtConfig);
  config.ssr = ctx.useNuxtSSR;
  config.features = {
    inlineStyles: !ctx.useNuxtModule,
    devLogs: !ctx.useNuxtModule
  };
  config.build = { transpile: ["vuetify"] };
  config.vite = {
    ssr: {
      noExternal: ["vuetify"]
    }
  };
  config.css = [];
  if (!ctx.useNuxtModule) {
    config.css.push("@mdi/font/css/materialdesignicons.css", "vuetify/styles");
  }
  addNuxtModule(nuxtConfig, "@nuxt/fonts");
  return config;
}
function copyResources(ctx, rootPath, templateDir) {
  const {
    useNuxtSSR,
    nuxtPreset,
    useNuxtModule,
    templateRoot
  } = ctx;
  const assetsDir = path3.join(rootPath, "assets");
  let templateAssetsDir = path3.join(templateRoot, "default/src/assets");
  fs3.mkdirSync(assetsDir);
  fs3.copyFileSync(
    path3.join(templateAssetsDir, "logo.png"),
    path3.join(assetsDir, "logo.png")
  );
  fs3.copyFileSync(
    path3.join(templateAssetsDir, "logo.svg"),
    path3.join(assetsDir, "logo.svg")
  );
  if (nuxtPreset !== "nuxt-default") {
    templateAssetsDir = path3.join(templateRoot, "base/src/styles");
    fs3.copyFileSync(
      path3.join(templateAssetsDir, "settings.scss"),
      path3.join(assetsDir, "settings.scss")
    );
  }
  const pluginsDir = path3.join(rootPath, "plugins");
  const templatePluginsDir = path3.join(templateDir, "plugins");
  fs3.mkdirSync(pluginsDir);
  if (useNuxtModule) {
    fs3.copyFileSync(
      path3.join(templateDir, "vuetify.config.ts"),
      path3.join(rootPath, "../vuetify.config.ts")
    );
    fs3.copyFileSync(
      path3.join(templatePluginsDir, "vuetify-nuxt.ts"),
      path3.join(pluginsDir, "vuetify.ts")
    );
  } else {
    const modulesDir = path3.join(rootPath, "../modules");
    const templateModulesDir = path3.join(templateDir, "modules");
    fs3.mkdirSync(modulesDir);
    fs3.copyFileSync(
      path3.resolve(templateModulesDir, "vuetify.ts"),
      path3.resolve(modulesDir, "vuetify.ts")
    );
    editFile(
      path3.join(templatePluginsDir, "vuetify.ts"),
      (content) => {
        return useNuxtSSR ? content : content.replace("ssr: true,", "ssr: false,");
      },
      path3.resolve(pluginsDir, "vuetify.ts")
    );
  }
  fs3.copyFileSync(
    path3.resolve(templateDir, nuxtPreset === "nuxt-essentials" ? "app-layout.vue" : "app.vue"),
    path3.resolve(rootPath, "app.vue")
  );
  if (nuxtPreset === "nuxt-essentials") {
    const layoutsDir = path3.join(rootPath, "layouts");
    const templateLayoutsDir = path3.join(templateDir, "layouts");
    fs3.mkdirSync(layoutsDir);
    fs3.copyFileSync(
      path3.resolve(templateLayoutsDir, "default.vue"),
      path3.resolve(layoutsDir, "default.vue")
    );
  }
  const componentsDir = path3.join(rootPath, "components");
  const templateComponentsDir = path3.join(templateDir, "components");
  fs3.mkdirSync(componentsDir);
  fs3.copyFileSync(
    path3.resolve(templateComponentsDir, "AppFooter.vue"),
    path3.resolve(componentsDir, "AppFooter.vue")
  );
  fs3.copyFileSync(
    path3.resolve(templateComponentsDir, "HelloWorld.vue"),
    path3.resolve(componentsDir, "HelloWorld.vue")
  );
  const pagesDir = path3.join(rootPath, "pages");
  const templatePagesDir = path3.join(templateDir, "pages");
  fs3.mkdirSync(pagesDir);
  fs3.copyFileSync(
    path3.resolve(templatePagesDir, "index.vue"),
    path3.resolve(pagesDir, "index.vue")
  );
}
function prepareNuxtModule(ctx, nuxtConfig) {
  const moduleOptions = {
    ssrClientHints: {
      reloadOnFirstRequest: false,
      viewportSize: ctx.useNuxtSSR && ctx.useNuxtSSRClientHints,
      prefersColorScheme: false,
      prefersColorSchemeOptions: {
        useBrowserThemeOnly: false
      }
    },
    styles: ctx.nuxtPreset === "nuxt-default" ? true : {
      configFile: "assets/settings.scss"
    }
  };
  configureVuetify(ctx, nuxtConfig);
  addNuxtModule(
    nuxtConfig,
    "vuetify-nuxt-module",
    "vuetify",
    { moduleOptions }
  );
}
function prepareVuetifyModule(ctx, nuxtConfig) {
  const config = configureVuetify(ctx, nuxtConfig);
  const styles = ctx.nuxtPreset === "nuxt-essentials" ? {
    configFile: "assets/settings.scss"
  } : true;
  config.vuetify = { autoImport: true, styles };
}
function prepareProject(ctx) {
  const {
    projectRoot,
    templatePath,
    useNuxtModule
  } = ctx;
  const [rootPath, templateDir] = getPaths(projectRoot, templatePath);
  const nuxtConfigFile = path3.join(rootPath, "../nuxt.config.ts");
  const nuxtConfig = parseModule(fs3.readFileSync(nuxtConfigFile, "utf8"));
  if (useNuxtModule) {
    prepareNuxtModule(ctx, nuxtConfig);
  } else {
    prepareVuetifyModule(ctx, nuxtConfig);
  }
  let code = generateCode(nuxtConfig, {
    trailingComma: true,
    quote: "single",
    arrayBracketSpacing: false,
    objectCurlySpacing: true,
    lineTerminator: "\n",
    format: {
      trailingComma: true,
      quote: "single",
      arrayBracketSpacing: false,
      objectCurlySpacing: true,
      useSemi: false
    }
  }).code;
  if (useNuxtModule) {
    code = code.replace("ssrClientHints:", `// check https://nuxt.vuetifyjs.com/guide/server-side-rendering.html
      ssrClientHints:`);
    code = code.replace("styles:", `// /* If customizing sass global variables ($utilities, $reset, $color-pack, $body-font-family, etc) */
      // disableVuetifyStyles: true,
      styles:`);
  } else {
    code = code.replace("ssr:", `// when enabling/disabling ssr option, remember to update ssr option in plugins/vuetify.ts
  ssr:`);
  }
  code = code.replace("features:", `// when enabling ssr option you need to disable inlineStyles and maybe devLogs
  features:`);
  fs3.writeFileSync(
    nuxtConfigFile,
    code,
    "utf8"
  );
  copyResources(ctx, rootPath, templateDir);
}

// src/index.ts
async function run() {
  const args = process.argv.slice(2).slice();
  const banner = createBanner();
  if (args.length === 0) {
    console.log(`
${banner}
`);
    const initialContext2 = {
      canOverwrite: false,
      cwd: process.cwd(),
      projectName: "vuetify-project"
    };
    const finalContext2 = await initPrompts(initialContext2);
    await createProject(finalContext2);
    return;
  }
  const cliOptions = parseCliArgs(args);
  if (cliOptions.help) {
    console.log(getHelpText());
    process.exit(0);
  }
  if (cliOptions.version) {
    console.log(getVersionText());
    process.exit(0);
  }
  console.log(`
${banner}
`);
  const cliContext = cliOptionsToContext(cliOptions, process.cwd());
  const initialContext = {
    cwd: cliContext.cwd,
    projectName: cliContext.projectName,
    canOverwrite: cliContext.canOverwrite,
    useTypeScript: cliContext.useTypeScript,
    usePreset: cliContext.usePreset,
    usePackageManager: cliContext.usePackageManager,
    installDependencies: cliContext.installDependencies,
    useNuxtModule: cliContext.useNuxtModule,
    useNuxtSSR: cliContext.useNuxtSSR,
    useNuxtSSRClientHints: cliContext.useNuxtSSRClientHints
  };
  const finalContext = resolveNonInteractiveContext(initialContext);
  await createProject(finalContext);
}
async function createProject(finalContext) {
  const {
    canOverwrite,
    cwd: cwd2,
    projectName,
    useTypeScript,
    usePackageManager,
    installDependencies: installDeps,
    usePreset,
    useNuxtModule,
    useNuxtSSR,
    useNuxtSSRClientHints
  } = finalContext;
  const projectRoot = join4(cwd2, projectName);
  if (canOverwrite && existsSync5(projectRoot)) {
    rmSync(projectRoot, { recursive: true });
  }
  const preset = finalContext.usePreset ?? usePreset;
  if (preset.startsWith("nuxt-")) {
    const templateRoot = resolve6(dirname3(fileURLToPath(import.meta.url)), "../template/typescript");
    const templatePath = resolve6(dirname3(fileURLToPath(import.meta.url)), "../template/typescript/nuxt");
    await renderNuxtTemplate({
      cwd: cwd2,
      projectName,
      projectRoot,
      templateRoot,
      templatePath,
      nuxtPreset: preset,
      useNuxtModule,
      useNuxtSSR,
      useNuxtSSRClientHints
    });
  } else {
    mkdirSync2(projectRoot);
    writeFileSync2(resolve6(projectRoot, "package.json"), JSON.stringify({ name: projectName }, null, 2));
    console.log("\n\u25CC Generating scaffold...");
    const jsOrTs = useTypeScript ? "typescript" : "javascript";
    const templatePath = resolve6(dirname3(fileURLToPath(import.meta.url)), "../template", jsOrTs);
    renderTemplate(resolve6(templatePath, "default"), projectRoot);
    if (["base", "essentials"].includes(usePreset)) {
      renderTemplate(resolve6(templatePath, "base"), projectRoot);
    }
    if (["essentials", "recommended"].includes(usePreset)) {
      renderTemplate(resolve6(templatePath, "essentials"), projectRoot);
    }
    if (usePackageManager && installDeps) {
      console.log(`\u25CC Installing dependencies with ${usePackageManager}...
`);
      await installDependencies2(projectRoot, usePackageManager);
    }
  }
  console.log(`
${projectName} has been generated at ${projectRoot}
`);
}
run().then(() => {
  console.log("Discord community: https://community.vuetifyjs.com");
  console.log("Github: https://github.com/vuetifyjs/vuetify");
  console.log("Support Vuetify: https://github.com/sponsors/johnleider");
  process.exit(0);
}).catch((error) => {
  console.error(`
${red3("\u2716")} ${error}
`);
  process.exit(1);
});
